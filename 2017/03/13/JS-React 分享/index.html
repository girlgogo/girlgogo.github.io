<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="JS,JS框架／库," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="React 分享1 React 入门教程
对应 React v0.14.x，使用 ES6。

1.1 React 概览React 的核心思想是：封装组件。各个组件维护自己的状态和 UI，当状态变更，自动重新渲染整个组件。基于这种方式的一个直观感受就是我们不再需要不厌其烦地来回查找某个 DOM 元素，然后操作 DOM 去更改 UI。
React 大体包含下面这些概念：

组件
JSX
Virtual">
<meta property="og:type" content="article">
<meta property="og:title" content="React分享">
<meta property="og:url" content="https://girlgogo.github.io/2017/03/13/JS-React 分享/index.html">
<meta property="og:site_name" content="girlgogo">
<meta property="og:description" content="React 分享1 React 入门教程
对应 React v0.14.x，使用 ES6。

1.1 React 概览React 的核心思想是：封装组件。各个组件维护自己的状态和 UI，当状态变更，自动重新渲染整个组件。基于这种方式的一个直观感受就是我们不再需要不厌其烦地来回查找某个 DOM 元素，然后操作 DOM 去更改 UI。
React 大体包含下面这些概念：

组件
JSX
Virtual">
<meta property="og:image" content="http://omqyp2bk2.bkt.clouddn.com/1478598153291.png">
<meta property="og:updated_time" content="2017-03-15T14:58:11.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="React分享">
<meta name="twitter:description" content="React 分享1 React 入门教程
对应 React v0.14.x，使用 ES6。

1.1 React 概览React 的核心思想是：封装组件。各个组件维护自己的状态和 UI，当状态变更，自动重新渲染整个组件。基于这种方式的一个直观感受就是我们不再需要不厌其烦地来回查找某个 DOM 元素，然后操作 DOM 去更改 UI。
React 大体包含下面这些概念：

组件
JSX
Virtual">
<meta name="twitter:image" content="http://omqyp2bk2.bkt.clouddn.com/1478598153291.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://girlgogo.github.io/2017/03/13/JS-React 分享/"/>





  <title> React分享 | girlgogo </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">girlgogo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">笔记分享</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://girlgogo.github.io/2017/03/13/JS-React 分享/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Emily">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="girlgogo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                React分享
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-13T23:30:32+08:00">
                2017-03-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript函数库-框架/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript函数库/框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="React-分享"><a href="#React-分享" class="headerlink" title="React 分享"></a>React 分享</h1><h2 id="1-React-入门教程"><a href="#1-React-入门教程" class="headerlink" title="1 React 入门教程"></a>1 React 入门教程</h2><blockquote>
<p>对应 React v0.14.x，使用 ES6。</p>
</blockquote>
<h3 id="1-1-React-概览"><a href="#1-1-React-概览" class="headerlink" title="1.1 React 概览"></a>1.1 React 概览</h3><p>React 的核心思想是：<strong>封装组件</strong>。<br>各个组件维护自己的状态和 UI，当状态变更，自动重新渲染整个组件。<br>基于这种方式的一个直观感受就是我们不再需要不厌其烦地来回查找某个 DOM 元素，然后操作 DOM 去更改 UI。</p>
<p>React 大体包含下面这些概念：</p>
<ul>
<li>组件</li>
<li>JSX</li>
<li>Virtual DOM</li>
<li>Data Flow</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloMessage</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 加载组件到 DOM 元素 mountNode</span></div><div class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">HelloMessage</span> <span class="attr">name</span>=<span class="string">"John"</span> /&gt;</span>, mountNode);</span></div></pre></td></tr></table></figure>
<h4 id="1-1-1-组件"><a href="#1-1-1-组件" class="headerlink" title="1.1.1 组件"></a>1.1.1 组件</h4><p><strong>React 应用都是构建在组件之上</strong>。<br>上面的<code>HelloMessage</code> 就是一个 React 构建的组件，最后一句 <code>render</code>会把这个组件显示到页面上的某个元素 <code>mountNode</code> 里面，显示的内容就是<code>&lt;div&gt;Hello John&lt;/div&gt;</code>。</p>
<blockquote>
<p><code>props</code> 是组件包含的两个核心概念之一，另一个是<code>state</code>。可以把 props 看作是组件的配置属性，在组件内部是不变的，只是在调用这个组件的时候传入不同的属性（比如这里的 name）来定制显示这个组件。</p>
</blockquote>
<h4 id="1-1-2-JSX"><a href="#1-1-2-JSX" class="headerlink" title="1.1.2 JSX"></a>1.1.2 JSX</h4><p> React 提出的 JSX 语法就是<strong>将 HTML 直接嵌入了 JS 代码里面</strong>。但实际上组件的 HTML 是组成一个组件不可分割的一部分，能够将 HTML 封装起来才是组件的完全体。</p>
<h4 id="1-1-3-Virtual-DOM"><a href="#1-1-3-Virtual-DOM" class="headerlink" title="1.1.3 Virtual DOM"></a>1.1.3 Virtual DOM</h4><p>当组件状态<code>state</code>有更改的时候，React 会自动调用组件的<code>render</code>方法<strong>重新渲染整个组件的 UI</strong>。</p>
<blockquote>
<p>当然如果真的这样大面积的操作 DOM，性能会是一个很大的问题，所以 React 实现了一个<code>Virtual DOM</code>，组件 DOM 结构就是映射到这个 Virtual DOM 上，React 在这个 Virtual DOM 上实现了一个 <code>diff</code> 算法，当要重新渲染组件的时候，会通过 diff 寻找到要变更的 DOM 节点，再把这个修改更新到浏览器实际的 DOM 节点上，所以实际上不是真的渲染整个 DOM 树。<strong>这个 Virtual DOM 是一个纯粹的 JS 数据结构</strong>，所以性能会比原生 DOM 快很多。</p>
</blockquote>
<h4 id="1-1-4-Data-Flow"><a href="#1-1-4-Data-Flow" class="headerlink" title="1.1.4 Data Flow"></a>1.1.4 Data Flow</h4><p><code>“单向数据绑定”</code>是 React 推崇的一种应用架构的方式。当<code>应用足够复杂时</code>才能体会到它的好处。</p>
<h3 id="1-2-开发环境配置"><a href="#1-2-开发环境配置" class="headerlink" title="1.2 开发环境配置"></a>1.2 开发环境配置</h3><p> React 开发环境：</p>
<ul>
<li>JSX 支持</li>
<li>ES6 支持</li>
</ul>
<p>现业界领先的 ES6 编译工具 Babel 随着作者被 Facebook 招入麾下，已经内置了对 JSX 的支持，我们只需要配置 Babel 一个编译工具就可以了，配合 webpack 非常方便。</p>
<h4 id="1-2-1-Webpack-配置-React-开发环境"><a href="#1-2-1-Webpack-配置-React-开发环境" class="headerlink" title="1.2.1 Webpack 配置 React 开发环境"></a>1.2.1 Webpack 配置 React 开发环境</h4><p><code>Webpack</code> 是一个<code>前端资源加载/打包工具</code>，只需要相对简单的配置就可以提供前端工程化需要的各种功能，并且如果有需要它还可以被整合到其他比如 Grunt / Gulp 的工作流。</p>
<p><strong>安装 Webpack</strong>：<code>npm install -g webpack</code><br>Webpack 使用一个名为 <code>webpack.config.js</code> 的配置文件，要<strong>编译 JSX</strong>，先安装对应的<code>loader: npm install babel-loader --save-dev</code></p>
<p>案例：<br>假设在当前工程目录有一个<code>入口文件 entry.js</code>，React 组件放置在一个 <code>components/</code>目录下，组件被 <code>entry.js</code> 引用，要使用 <code>entry.js</code>，我们把这个文件指定输出到<code>dist/bundle.js</code>，<strong>Webpack 配置如下</strong>：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">entry</span>: <span class="string">'./entry.js'</span>,</div><div class="line">  <span class="attr">output</span>: &#123;</div><div class="line">    <span class="attr">path</span>: path.join(__dirname, <span class="string">'/dist'</span>),</div><div class="line">    <span class="attr">filename</span>: <span class="string">'bundle.js'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">resolve</span>: &#123;</div><div class="line">    <span class="attr">extensions</span>: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'.jsx'</span>]</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">module</span>: &#123;</div><div class="line">    <span class="attr">loaders</span>: [</div><div class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.js|jsx$/</span>, <span class="attr">loaders</span>: [<span class="string">'babel'</span>] &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>resolve</code>指定可以被 <code>import</code>的文件后缀。比如<code>Hello.jsx</code> 这样的文件就可以直接用<code>import Hello from &#39;Hello&#39;</code>引用。</li>
<li><code>loaders</code>指定 <code>babel-loader</code>编译后缀名为 <code>.js</code>或者<code>.jsx</code>的文件，这样你就可以在这两种类型的文件中自由使用<strong>JSX</strong>和<strong>ES6</strong>了。<br>监听编译:<code>webpack -d --watch</code></li>
</ul>
<h3 id="1-3-JSX"><a href="#1-3-JSX" class="headerlink" title="1.3 JSX"></a>1.3 JSX</h3><p>1、为什么要引入 JSX 这种语法<br>传统的 MVC 是将模板放在其他地方，比如 <code>&lt;script&gt;</code>标签或者<code>模板文件</code>，再在 JS 中通过某种手段引用模板。<br>React 认为组件才是王道，而组件是和模板紧密关联的，组件模板和组件逻辑分离让问题复杂化了。所以就有了 JSX 这种语法，就是<code>为了把 HTML 模板直接嵌入到 JS 代码里面</code>，这样就做到了模板和组件关联，但是 JS 不支持这种包含 HTML 的语法，所以需要通过工具将 JSX 编译输出成 JS 代码才能使用。</p>
<p>2、JSX 是可选的<br>因为 JSX 最终是输出成 JS 代码来表达的，所以可以直接用 React 提供的这些 DOM 构建方法来写模板，比如一个 JSX 写的一个链接：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://facebook.github.io/react/"</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure>
<p>用 JS 代码来写就成这样了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">React.createElement(<span class="string">'a'</span>, &#123;<span class="attr">href</span>: <span class="string">'http://facebook.github.io/react/'</span>&#125;, <span class="string">'Hello!'</span>)</div></pre></td></tr></table></figure>
<p>通过<code>React.createElement</code>来构造组件的 DOM 树。<strong>第一个参数是标签名，第二个参数是属性对象，第三个参数是子元素</strong>。<br>一个包含子元素的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> child = React.createElement(<span class="string">'li'</span>, <span class="literal">null</span>, <span class="string">'Text Content'</span>);</div><div class="line"><span class="keyword">var</span> root = React.createElement(<span class="string">'ul'</span>, &#123; <span class="attr">className</span>: <span class="string">'my-list'</span> &#125;, child);</div><div class="line">React.render(root, <span class="built_in">document</span>.body);</div></pre></td></tr></table></figure>
<p>对于常见的 HTML 标签，React 已经内置了工厂方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> root = React.DOM.ul(&#123; <span class="attr">className</span>: <span class="string">'my-list'</span> &#125;,</div><div class="line">  React.DOM.li(<span class="literal">null</span>, <span class="string">'Text Content'</span>)</div><div class="line">);</div></pre></td></tr></table></figure>
<p> JSX 和 JS 之间的转换也很简单直观，用 JSX 的好处就是它基本上就是 HTML。</p>
<h4 id="1-3-1-使用-JSX"><a href="#1-3-1-使用-JSX" class="headerlink" title="1.3.1 使用 JSX"></a>1.3.1 使用 JSX</h4><p>1、使用 JSX<br>利用 JSX 编写 DOM 结构，可以用<strong>原生的 HTML 标签</strong>，也可以直接像<strong>普通标签一样引用 React 组件</strong>。这两者约定通过<code>大小写</code>来区分，<code>小写的字符串是 HTML 标签</code>，<code>大写开头的变量是 React 组件</code>。</p>
<p>使用 HTML 标签：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> myDivElement = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"foo"</span> /&gt;</span>;</span></div><div class="line">render(myDivElement, document.getElementById('mountNode'));</div></pre></td></tr></table></figure>
<p>HTML 里的<code>class</code>在 JSX 里要写成 <code>className</code>，因为 class 在 JS 里是保留关键字。同理某些属性比如<code>for</code>要写成<code>htmlFor</code>。</p>
<p>使用组件：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'./MyComponet'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> myElement = <span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">someProperty</span>=<span class="string">&#123;true&#125;</span> /&gt;</span>;</span></div><div class="line">render(myElement, document.body);</div></pre></td></tr></table></figure>
<p>2、使用 JavaScript 表达式<br><code>属性值</code>使用表达式，只要用<code>{}</code>替换<code>&quot;&quot;</code>:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Input (JSX):</span></div><div class="line"><span class="keyword">var</span> person = <span class="xml"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">name</span>=<span class="string">&#123;window.isLoggedIn</span> ? <span class="attr">window.name</span> <span class="attr">:</span> ''&#125; /&gt;</span>;</span></div><div class="line">// Output (JS):</div><div class="line">var person = React.createElement(</div><div class="line">  Person,</div><div class="line">  &#123;name: window.isLoggedIn ? window.name : ''&#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>子组件也可以作为表达式使用：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Input (JSX):</span></div><div class="line"><span class="keyword">var</span> content = <span class="xml"><span class="tag">&lt;<span class="name">Container</span>&gt;</span>&#123;window.isLoggedIn ? <span class="tag">&lt;<span class="name">Nav</span> /&gt;</span> : <span class="tag">&lt;<span class="name">Login</span> /&gt;</span>&#125;<span class="tag">&lt;/<span class="name">Container</span>&gt;</span></span>;</div><div class="line"><span class="comment">// Output (JS):</span></div><div class="line"><span class="keyword">var</span> content = React.createElement(</div><div class="line">  Container,</div><div class="line">  <span class="literal">null</span>,</div><div class="line">  <span class="built_in">window</span>.isLoggedIn ? React.createElement(Nav) : React.createElement(Login)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>3、注释<br>在 JSX 里使用注释也很简单，就是沿用 JavaScript，唯一要注意的是<code>在一个组件的子元素位置使用注释要用 {} 包起来</code>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> content = (</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Nav</span>&gt;</span></span></div><div class="line">    &#123;/* child comment, put &#123;&#125; around */&#125;</div><div class="line">    <span class="tag">&lt;<span class="name">Person</span></span></div><div class="line">      /* <span class="attr">multi</span></div><div class="line">         <span class="attr">line</span></div><div class="line">         <span class="attr">comment</span> */</div><div class="line">      <span class="attr">name</span>=<span class="string">&#123;window.isLoggedIn</span> ? <span class="attr">window.name</span> <span class="attr">:</span> ''&#125; // <span class="attr">end</span> <span class="attr">of</span> <span class="attr">line</span> <span class="attr">comment</span></div><div class="line">    /&gt;</div><div class="line">  <span class="tag">&lt;/<span class="name">Nav</span>&gt;</span></div><div class="line">);</div></pre></td></tr></table></figure>
<p>4、HTML 转义<br><strong>React 会将所有要显示到 DOM 的字符串转义</strong>，防止 XSS。所以如果 JSX 中含有转义后的实体字符比如 <code>&amp;copy;</code> (©) 最后显示到 DOM 中不会正确显示，因为 React 自动把 <code>&amp;copy;</code>中的特殊字符转义了。<br>有几种解决办法：</p>
<ul>
<li>直接使用 UTF-8 字符 ©</li>
<li>使用对应字符的 Unicode 编码，查询编码</li>
<li>使用数组组装 <code>&lt;div&gt;{[&#39;cc &#39;, &lt;span&gt;&amp;copy;&lt;/span&gt;, &#39; 2015&#39;]}&lt;/div&gt;</code></li>
<li>直接插入原始的 HTML</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;&#123;__html:</span> '<span class="attr">cc</span> &amp;<span class="attr">copy</span>; <span class="attr">2015</span>'&#125;&#125; /&gt;</span></div></pre></td></tr></table></figure>
<p>5、自定义 HTML 属性<br>如果在 JSX 中使用的属性不存在于 HTML 的规范中，这个属性会被忽略。如果要使用自定义属性，可以用<code>data-</code>前缀。<br>可访问性属性的前缀 <code>aria-</code>也是支持的。</p>
<p>6、支持的标签和属性<br>如果你要使用的某些标签或属性不在这些支持列表里面就可能被 React 忽略，必须要使用的话可以提 <code>issue</code>，或者用前面提到的 <code>dangerouslySetInnerHTML</code>。</p>
<h4 id="1-3-2-属性扩散"><a href="#1-3-2-属性扩散" class="headerlink" title="1.3.2 属性扩散"></a>1.3.2 属性扩散</h4><p>1、属性扩散<br>有时候需要<code>给组件设置多个属性</code>，但不想一个个写下这些属性，或者有时候你甚至不知道这些属性的名称，这时候<code>spread attributes</code>的功能就很有用了。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> props = &#123;&#125;;</div><div class="line">props.foo = x;</div><div class="line">props.bar = y;</div><div class="line"><span class="keyword">var</span> component = <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span>;</span></div></pre></td></tr></table></figure>
<p><code>props</code>对象的属性会被设置成 <code>Component</code>的属性。<br><strong>属性也可以被覆盖</strong>：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> props = &#123; <span class="attr">foo</span>: <span class="string">'default'</span> &#125;;</div><div class="line"><span class="keyword">var</span> component = <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">foo</span>=<span class="string">&#123;</span>'<span class="attr">override</span>'&#125; /&gt;</span>;</span></div><div class="line">console.log(component.props.foo); // 'override'</div></pre></td></tr></table></figure>
<p>写在后面的属性值会覆盖前面的属性。</p>
<h4 id="1-3-3-JSX-与-HTML-的差异"><a href="#1-3-3-JSX-与-HTML-的差异" class="headerlink" title="1.3.3 JSX 与 HTML 的差异"></a>1.3.3 JSX 与 HTML 的差异</h4><p>除了前面提到的 <code>class</code>要写成<code>className</code>，比较典型的还有:</p>
<ul>
<li><code>style</code>属性接受由 CSS 属性构成的 JS 对象</li>
<li><code>onChange</code>事件表现更接近我们的直觉（不需要 <code>onBlur</code>去触发）</li>
<li><code>表单</code>的表现差异比较大</li>
</ul>
<h3 id="1-4-React-组件"><a href="#1-4-React-组件" class="headerlink" title="1.4 React 组件"></a>1.4 React 组件</h3><p>1、组件有两个核心概念：</p>
<ul>
<li>props</li>
<li>state</li>
</ul>
<p>一个组件就是通过这两个属性的值在<code>render</code>方法里面生成这个组件对应的 <strong>HTML 结构</strong>。<br>注意：组件生成的 HTML 结构<code>只能有一个单一的根节点</code>。<br>2、props<br><code>props</code>就是组件的属性，由外部通过 JSX 属性传入设置，一旦初始设置完成，就可以认为<code>this.props</code> 是不可更改的，所以不要轻易更改设置<code>this.props</code>里面的值（虽然对于一个 JS 对象你可以做任何事）。<br>3、state<br><code>state</code>是组件的当前状态，可以把组件简单看成一个“状态机”，根据状态 <code>state</code>呈现不同的<strong> UI </strong>展示。<br>一旦状态（数据）更改，组件就会自动调用<code>render</code>重新渲染 UI，这个更改的动作会通过 <code>this.setState</code>方法来触发。<br>4、划分状态数据</p>
<blockquote>
<p>一条原则：<strong>让组件尽可能地少状态</strong>。</p>
</blockquote>
<p>当<strong>更改这个状态（数据）需要更新组件 UI </strong>的就可以认为是 <code>state</code>，下面这些可以认为<strong>不是状态</strong>：</p>
<ul>
<li>可计算的数据：比如一个数组的长度</li>
<li>和 props 重复的数据：除非这个数据是要做变更的</li>
</ul>
<p>5、无状态组件<br>可以用纯粹的函数来定义无状态的组件<code>(stateless function)</code>，这种组件<strong>没有状态</strong>，<strong>没有生命周期</strong>，只是简单的<strong>接受 props 渲染生成 DOM 结构</strong>。无状态组件非常简单，开销很低，如果可能的话尽量使用无状态组件。比如使用箭头函数定义：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const HelloMessage = (props) =&gt; &lt;div&gt; Hello &#123;props.name&#125;&lt;/div&gt;;</div><div class="line">render(&lt;HelloMessage name="John" /&gt;, mountNode);</div></pre></td></tr></table></figure>
<p>因为无状态组件只是函数，所以它<strong>没有实例返回</strong>，这点在想用 <code>refs</code>获取无状态组件的时候要注意，参见DOM 操作。</p>
<h4 id="1-4-1-组件生命周期"><a href="#1-4-1-组件生命周期" class="headerlink" title="1.4.1 组件生命周期"></a>1.4.1 组件生命周期</h4><blockquote>
<p>一般来说，一个组件类由<code>extends Component</code>创建，并且提供一个<code>render</code>方法以及<strong>其他可选的生命周期函数</strong>、<strong>组件相关的事件</strong>或<strong>方法</strong>来定义。</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LikeButton</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">liked</span>: <span class="literal">false</span> &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  handleClick(e) &#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">liked</span>: !<span class="keyword">this</span>.state.liked &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">const</span> text = <span class="keyword">this</span>.state.liked ? <span class="string">'like'</span> : <span class="string">'haven\'t liked'</span>;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick.bind(this)&#125;</span>&gt;</span></span></div><div class="line">          You &#123;text&#125; this. Click to toggle.</div><div class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">render(</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">LikeButton</span> /&gt;</span>,</span></div><div class="line">    document.getElementById('example')</div><div class="line">);</div></pre></td></tr></table></figure>
<p>1、<strong>getInitialState</strong><br>初始化<code>this.state</code>的值，只在组件装载之前调用一次。<br>如果是使用<code>ES6</code>的语法，你也可以<strong>在构造函数中初始化状态</strong>，比如：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">count</span>: props.initialCount &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2、<strong>getDefaultProps</strong><br>只在组件创建时调用一次并缓存返回的对象（即在<code>React.createClass</code>之后就会调用）。<br>因为这个方法在实例初始化之前调用，所以在这个方法里面不能依赖<code>this</code> 获取到这个组件的实例。<br>在组件装载之后，这个方法缓存的结果会用来保证访问<code>this.props</code>的属性时，当这个属性没有在父组件中传入（在这个组件的 JSX 属性里设置），也总是有值的。<br>如果是使用 <code>ES6</code>语法，可以直接定义 <code>defaultProps</code>这个类属性来替代，这样能更直观的知道<code>default props</code>是预先定义好的对象值：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Counter.defaultProps = &#123; <span class="attr">initialCount</span>: <span class="number">0</span> &#125;;</div></pre></td></tr></table></figure>
<p>3、<strong>render</strong>（必须）<br>组装生成这个组件的 <strong>HTML 结构</strong>（使用原生 HTML 标签或者子组件），也可以返回<code>null</code>或者 <code>false</code>，这时候<code>ReactDOM.findDOMNode(this)</code>会返回<code>null</code>。</p>
<p>4、<strong>生命周期函数</strong><br><strong>装载组件触发</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">componentWillMount</div></pre></td></tr></table></figure>
<p>只会在装载之前调用一次，在<code>render</code>之前调用，可以在这个方法里面调用 <code>setState</code>改变状态，并且不会导致额外调用一次<code>render</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">componentDidMount</div></pre></td></tr></table></figure>
<p>只会在装载完成之后调用一次，在<code>render</code> 之后调用，从这里开始可以通过 <code>ReactDOM.findDOMNode(this)</code>获取到组件的 DOM 节点。<br><strong>更新组件触发</strong><br>这些方法不会在首次 render 组件的周期调用</p>
<ul>
<li>componentWillReceiveProps</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>componentDidUpdate</li>
</ul>
<p><strong>卸载组件触发</strong></p>
<ul>
<li>componentWillUnmount</li>
</ul>
<h4 id="1-4-2-事件处理（还需要再看看）"><a href="#1-4-2-事件处理（还需要再看看）" class="headerlink" title="1.4.2 事件处理（还需要再看看）"></a>1.4.2 事件处理（还需要再看看）</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LikeButton</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">liked</span>: <span class="literal">false</span> &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  handleClick(e) &#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">liked</span>: !<span class="keyword">this</span>.state.liked &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">const</span> text = <span class="keyword">this</span>.state.liked ? <span class="string">'like'</span> : <span class="string">'haven\'t liked'</span>;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick.bind(this)&#125;</span>&gt;</span></span></div><div class="line">          You &#123;text&#125; this. Click to toggle.</div><div class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">render(</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">LikeButton</span> /&gt;</span>,</span></div><div class="line">  document.getElementById('example')</div><div class="line">);</div></pre></td></tr></table></figure>
<p>可以看到 React 里面绑定事件的方式和在 HTML 中绑定事件类似，使用<strong>驼峰式命名</strong>指定要绑定的<code>onClick</code>属性为组件定义的一个方法 <code>{this.handleClick.bind(this)}</code>。</p>
<blockquote>
<p>注意要显式调用 <code>bind(this)</code>将事件函数上下文绑定要组件实例上，这也是 React 推崇的原则：没有黑科技，尽量使用显式的容易理解的 JavaScript 代码。</p>
</blockquote>
<p><strong>“合成事件”</strong>和<strong>“原生事件”</strong><br>React 实现了一个<strong>“合成事件”层</strong>（synthetic event system），这个事件模型<strong>保证了和 W3C 标准保持一致</strong>，并且这个事件层<strong>消除了 IE 与 W3C 标准实现之间的兼容问题</strong>。<br>“合成事件”还提供了额外的好处：<br><strong>事件委托</strong></p>
<blockquote>
<p>“合成事件”会以事件委托（<code>event delegation</code>）的方式绑定到组件最上层，并且在组件卸载（<code>unmount</code>）的时候自动销毁绑定的事件。3</p>
</blockquote>
<p><strong>什么是“原生事件”？</strong></p>
<blockquote>
<p>比如在<code>componentDidMount</code>方法里面通过 <code>addEventListener</code> 绑定的事件就是浏览器原生事件。</p>
</blockquote>
<p>使用原生事件的时候注意在 <code>componentWillUnmount</code>解除绑定 <code>removeEventListener</code>。</p>
<blockquote>
<p>所有通过 JSX 这种方式绑定的事件都是绑定到“合成事件”，除非你有特别的理由，建议总是用 React 的方式处理事件。</p>
</blockquote>
<p>Tips<br>如果混用“合成事件”和“原生事件”，比如一种常见的场景是用原生事件在<code>document</code> 上绑定，然后在组件里面绑定的合成事件想要通过 <code>e.stopPropagation()</code>来阻止事件冒泡到 <code>document</code>，这时候是行不通的，参见 Event delegation，因为<code>e.stopPropagation</code>是内部“合成事件” 层面的，解决方法是要用 <code>e.nativeEvent.stopImmediatePropagation()</code>。<br>”合成事件“ 的 event 对象只在当前 <code>event loop</code>有效，比如你想在事件里面调用一个 <code>promise</code>，在<code>resolve</code>之后去拿 event 对象会拿不到（并且没有错误抛出）：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">handleClick(e) &#123;</div><div class="line">  promise.then(<span class="function"><span class="params">()</span> =&gt;</span> doSomethingWith(e));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>参数传递</strong><br>给事件处理函数传递额外参数的方式：bind(this, arg1, arg2, …)<br>render: function() {<br>    return </p><p onclick="{this.handleClick.bind(this," 'extra="" param')}="">;<br>},<br>handleClick: function(param, event) {<br>    // handle click<br>}</p>
<h4 id="1-4-3-DOM-操作"><a href="#1-4-3-DOM-操作" class="headerlink" title="1.4.3 DOM 操作"></a>1.4.3 DOM 操作</h4><p>大部分情况下不需要通过查询 DOM 元素去更新组件的 UI，只要关注设置组件的状态（<code>setState</code>）。但是可能在某些情况下确实需要直接操作 DOM。<br>首先<code>ReactDOM.render</code>组件返回<strong>对组件的引用</strong>也就是组件实例（对于无状态状态组件来说返回 null），注意 <strong>JSX 返回的不是组件实例，它只是一个 ReactElement 对象</strong>（还记得我们用纯 JS 来构建 JSX 的方式吗）</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// A ReactElement</span></div><div class="line"><span class="keyword">const</span> myComponent = <span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span></span></div><div class="line"></div><div class="line">// render</div><div class="line">const myComponentInstance = ReactDOM.render(myComponent, mountNode);</div><div class="line">myComponentInstance.doSomething();</div></pre></td></tr></table></figure>
<p><strong>findDOMNode()</strong></p>
<blockquote>
<p>当组件加载到页面上之后（<code>mounted</code>），都可以通过<code>react-dom</code>提供的<code>findDOMNode()</code>方法拿到组件对应的 DOM 元素。</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; findDOMNode &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"></div><div class="line"><span class="comment">// Inside Component class</span></div><div class="line">componentDidMound() &#123;</div><div class="line">  <span class="keyword">const</span> el = findDOMNode(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>findDOMNode()</code>不能用在无状态组件上。</p>
<p><strong>Refs</strong></p>
<blockquote>
<p>另外一种方式就是通过在要引用的 DOM 元素上面设置一个<code>ref</code>属性指定一个名称，然后通过<code>this.refs.name</code>来访问对应的 DOM 元素。</p>
</blockquote>
<p>比如有一种情况是必须直接操作 DOM 来实现的，希望一个<code>&lt;input/&gt;</code>元素在清空它的值时 <code>focus</code>，没法仅仅靠 <code>state</code>来实现这个功能。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">return</span> &#123; <span class="attr">userInput</span>: <span class="string">''</span> &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  handleChange(e) &#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">userInput</span>: e.target.value &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  clearAndFocusInput() &#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">userInput</span>: <span class="string">''</span> &#125;, () =&gt; &#123;</div><div class="line">      <span class="keyword">this</span>.refs.theInput.focus();</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.clearAndFocusInput.bind(this)&#125;</span>&gt;</span></div><div class="line">          Click to Focus and Reset</div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">input</span></span></div><div class="line">          <span class="attr">ref</span>=<span class="string">"theInput"</span></div><div class="line">          <span class="attr">value</span>=<span class="string">&#123;this.state.userInput&#125;</span></div><div class="line">          <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange.bind(this)&#125;</span></div><div class="line">        /&gt;</div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果 <code>ref</code>是设置在原生 HTML 元素上，它拿到的就是 <strong>DOM 元素</strong>，如果设置在<strong>自定义组件</strong>上，它拿到的就是<strong>组件实例</strong>，这时候就需要通过<code>findDOMNode</code>来拿到组件的 DOM 元素。</p>
<blockquote>
<p>因为无状态组件没有实例，所以<strong><code>ref</code>不能设置在无状态组件上</strong>，一般来说这没什么问题，因为无状态组件没有实例方法，不需要 ref 去拿实例调用相关的方法，但是如果想要拿无状态组件的 DOM 元素的时候，就需要<strong>用一个状态组件封装一层，然后通过 <code>ref</code>和 <code>findDOMNode</code> 去获取</strong>。</p>
</blockquote>
<p><strong>ref 总结</strong></p>
<ul>
<li>可以使用 ref 到的组件定义的任何公共方法，比如<code>this.refs.myTypeahead.reset()</code></li>
<li>Refs 是<strong>访问到组件内部 DOM 节点唯一可靠的方法</strong></li>
<li>Refs 会自动销毁对子组件的引用（当子组件删除时）</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li>不要在 <code>render</code>或者<code>render</code>之前访问 <code>refs</code></li>
<li>不要滥用 <code>refs</code>，比如只是用它来按照传统的方式操作界面 UI：找到 DOM -&gt; 更新 DOM</li>
</ul>
<h4 id="1-4-4-组合组件"><a href="#1-4-4-组合组件" class="headerlink" title="1.4.4 组合组件"></a>1.4.4 组合组件</h4><p>1、<strong>组合组件</strong></p>
<blockquote>
<p>使用组件的目的就是<strong>通过构建模块化的组件，相互组合组件最后组装成一个复杂的应用</strong>。<br>在 React 组件中要包含其他组件作为子组件，只需要<strong>把组件当作一个 DOM 元素引入</strong>就可以了。</p>
</blockquote>
<p>例子：<br>一个显示用户头像的组件<code>Avatar</code>包含两个子组件 <code>ProfilePic</code> 显示用户头像和<code>ProfileLink</code>显示用户链接：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> ProfilePic = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;img src=&#123;'http://graph.facebook.com/' + props.username + '/picture'&#125; /&gt;</div><div class="line">  );</div><div class="line">&#125;</div><div class="line"></div><div class="line">const ProfileLink = (props) =&gt; &#123;</div><div class="line">  return (</div><div class="line">    &lt;a href=&#123;'http://www.facebook.com/' + props.username&#125;&gt;</div><div class="line">      &#123;props.username&#125;</div><div class="line">    &lt;/a&gt;</div><div class="line">  );</div><div class="line">&#125;</div><div class="line"></div><div class="line">const Avatar = (props) =&gt; &#123;</div><div class="line">  return (</div><div class="line">    &lt;div&gt;</div><div class="line">      &lt;ProfilePic username=&#123;props.username&#125; /&gt;</div><div class="line">      &lt;ProfileLink username=&#123;props.username&#125; /&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  );</div><div class="line">&#125;</div><div class="line"></div><div class="line">render(</div><div class="line">  &lt;Avatar username="pwh" /&gt;,</div><div class="line">  document.getElementById('example')</div><div class="line">);</div></pre></td></tr></table></figure>
<p>通过<code>props</code>传递值。</p>
<p>2、<strong>循环插入子元素</strong><br>如果组件中包含通过循环插入的子元素，为了保证重新渲染 UI 的时候能够正确显示这些子元素，每个元素都需要通过一个特殊的 <code>key</code>属性指定一个唯一值。具体原因见这里，为了内部<code>diff</code>的效率。<br><code>key</code>必须直接在循环中设置：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">const ListItemWrapper = (props) =&gt; &lt;li&gt;&#123;props.data.text&#125;&lt;/li&gt;;</div><div class="line"></div><div class="line">const MyComponent = (props) =&gt; &#123;</div><div class="line">  return (</div><div class="line">    &lt;ul&gt;</div><div class="line">      &#123;props.results.map((result) =&gt; &#123;</div><div class="line">        return &lt;ListItemWrapper key=&#123;result.id&#125; data=&#123;result&#125;/&gt;;</div><div class="line">      &#125;)&#125;</div><div class="line">    &lt;/ul&gt;</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也可以<strong>用一个 <code>key</code>值作为属性，子元素作为属性值的对象字面量来显示子元素列表</strong>，虽然这种用法的场景有限，参见<code>Keyed Fragments</code>，但是在这种情况下要注意生成的子元素重新渲染后在 DOM 中显示的顺序问题。<br>实际上浏览器在遍历一个字面量对象的时候会保持顺序一致，除非存在属性值可以被转换成整数值，这种属性值会排序并放在其他属性之前被遍历到，所以为了防止这种情况发生，可以在构建这个字面量的时候在<code>key</code> 值前面加<strong>字符串前缀</strong>，比如：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">render() &#123;</div><div class="line">  <span class="keyword">var</span> items = &#123;&#125;;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.props.results.forEach(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</div><div class="line">    <span class="comment">// If result.id can look like a number (consider short hashes), then</span></div><div class="line">    <span class="comment">// object iteration order is not guaranteed. In this case, we add a prefix</span></div><div class="line">    <span class="comment">// to ensure the keys are strings.</span></div><div class="line">    items[<span class="string">'result-'</span> + result.id] = <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;result.text&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span></div><div class="line">      &#123;items&#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></div><div class="line">   );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3、<strong>this.props.children</strong><br>组件标签里面包含的子元素会通过 <code>props.children</code>传递进来。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">React.render(<span class="xml"><span class="tag">&lt;<span class="name">Parent</span>&gt;</span><span class="tag">&lt;<span class="name">Child</span> /&gt;</span><span class="tag">&lt;/<span class="name">Parent</span>&gt;</span></span>, <span class="built_in">document</span>.body);</div><div class="line"></div><div class="line">React.render(<span class="xml"><span class="tag">&lt;<span class="name">Parent</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#123;'world'&#125;<span class="tag">&lt;/<span class="name">Parent</span>&gt;</span></span>, <span class="built_in">document</span>.body);</div></pre></td></tr></table></figure>
<p>HTML 元素会作为<strong> React</strong> 组件对象、<strong>JS</strong> 表达式结果是一个文字节点，都会存入<code>Parent</code>组件的 <code>props.children</code><br>一般来说，可以直接将这个属性作为父组件的子元素<code>render</code>：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Parent = <span class="function">(<span class="params">props</span>) =&gt;</span> &lt;div&gt;&#123;props.children&#125;&lt;<span class="regexp">/div&gt;;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><code>props.children</code> 通常是一个组件对象的数组，但是当只有一个子元素的时候，<code>props.children</code> 将是这个唯一的子元素，而不是数组了。</p>
</blockquote>
<p><code>React.Children</code>提供了额外的方法方便操作这个属性。</p>
<h4 id="1-4-5-组件间通信"><a href="#1-4-5-组件间通信" class="headerlink" title="1.4.5 组件间通信"></a>1.4.5 组件间通信</h4><p>1、<strong>父子组件间通信</strong><br>通过<code>props</code>属性传递，在父组件给子组件设置 <code>props</code>，然后子组件就可以通过 <code>props</code>访问到父组件的数据／方法，这样就搭建起了父子组件间通信的桥梁。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GroceryList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  handleClick(i) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'You clicked: '</span> + <span class="keyword">this</span>.props.items[i]);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">        &#123;this.props.items.map((item, i) =&gt; &#123;</div><div class="line">          return (</div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick.bind(this,</span> <span class="attr">i</span>)&#125; <span class="attr">key</span>=<span class="string">&#123;i&#125;</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">          );</div><div class="line">        &#125;)&#125;</div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">render(</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">GroceryList</span> <span class="attr">items</span>=<span class="string">&#123;[</span>'<span class="attr">Apple</span>', '<span class="attr">Banana</span>', '<span class="attr">Cranberry</span>']&#125; /&gt;</span>, mountNode</span></div><div class="line">);</div></pre></td></tr></table></figure>
<p><code>div</code>可以看作一个子组件，指定它的 <code>onClick</code>事件调用父组件的方法。</p>
<blockquote>
<p>父组件访问子组件？用<code>refs</code></p>
</blockquote>
<p>2、<strong>非父子组件间的通信</strong><br>使用<strong>全局事件 Pub/Sub 模式</strong>，在 <code>componentDidMount</code>里面订阅事件，在 <code>componentWillUnmount</code>里面取消订阅，当收到事件触发的时候调用<code>setState</code> 更新 UI。+</p>
<blockquote>
<p>这种模式在复杂的系统里面可能会变得难以维护，所以看个人权衡是否将组件封装到大的组件，甚至整个页面或者应用就封装到一个组件。<br>一般来说，对于比较复杂的应用，推荐使用类似 <code>Flux</code>这种单项数据流架构，参见<code>Data Flow</code>。</p>
</blockquote>
<h4 id="1-4-6-Minxins（再看看）"><a href="#1-4-6-Minxins（再看看）" class="headerlink" title="1.4.6 Minxins（再看看）"></a>1.4.6 Minxins（再看看）</h4><p>NOTE: 使用 <code>ES6 class</code>定义的组件已经不支持 <code>mixin</code>了，因为使用 mixin 的场景都可以用组合组件这种模式来做到，参见 <code>Mixins Are Dead. Long Live Composition</code>。</p>
<blockquote>
<p>虽然组件的原则就是模块化，彼此之间相互独立，但是有时候不同的组件之间可能会共用一些功能，共享一部分代码。所以 React 提供了 <code>mixins</code>这种方式来处理这种问题。</p>
</blockquote>
<p>Mixin 就是用来定义一些方法，使用这个 mixin 的组件能够自由的使用这些方法（就像在组件中定义的一样），所以 mixin 相当于组件的一个扩展，在 mixin 中也能定义“生命周期”方法。<br>比如一个定时器的 mixin：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> SetIntervalMixin = &#123;</div><div class="line">  <span class="attr">componentWillMount</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.intervals = [];</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">setInterval</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.intervals.push(setInterval.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>));</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">componentWillUnmount</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.intervals.map(clearInterval);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> TickTock = React.createClass(&#123;</div><div class="line">  <span class="attr">mixins</span>: [SetIntervalMixin], <span class="comment">// Use the mixin</span></div><div class="line">  getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;<span class="attr">seconds</span>: <span class="number">0</span>&#125;;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">componentDidMount</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.setInterval(<span class="keyword">this</span>.tick, <span class="number">1000</span>); <span class="comment">// Call a method on the mixin</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">tick</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">seconds</span>: <span class="keyword">this</span>.state.seconds + <span class="number">1</span>&#125;);</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></div><div class="line">        React has been running for &#123;this.state.seconds&#125; seconds.</div><div class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">React.render(</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">TickTock</span> /&gt;</span>,</span></div><div class="line">  document.getElementById('example')</div><div class="line">);</div></pre></td></tr></table></figure>
<p>React 的 <code>mixins</code> 的强大之处在于，如果一个组件使用了多个 mixins，其中几个 mixins 定义了相同的<strong>“生命周期方法”</strong>，这些方法会在组件相应的方法执行完之后按 mixins 指定的数组顺序执行。</p>
<h3 id="1-5-Data-Flow"><a href="#1-5-Data-Flow" class="headerlink" title="1.5 Data Flow"></a>1.5 Data Flow</h3><p>Data Flow 只是<code>一种应用架构的方式</code>，比如数据如何存放，如何更改数据，如何通知数据更改等等，所以它不是 React 提供的额外的什么新功能，可以看成<strong>是使用 React 构建大型应用的一种最佳实践</strong>。<br>正因为它是这样一种概念，所以涌现了许多实现，这里主要关注两种实现：</p>
<ul>
<li>官方的 Flux</li>
<li>更优雅的 Redux</li>
</ul>
<h4 id="1-5-1-Flux"><a href="#1-5-1-Flux" class="headerlink" title="1.5.1 Flux"></a>1.5.1 Flux</h4><blockquote>
<p>React 标榜自己是 MVC 里面 V 的部分，那么 Flux 就相当于添加 M 和 C 的部分。Flux 是 Facebook 使用的一套前端应用的架构模式。</p>
</blockquote>
<p>一个 Flux 应用主要包含四个部分：</p>
<ul>
<li>the dispatcher<br>处理动作分发，维护 Store 之间的依赖关系</li>
<li>the stores<br>数据和逻辑部分</li>
<li>the views<br>React 组件，这一层可以看作<code>controller-views</code>，作为视图同时响应用户交互</li>
<li>the actions<br>提供给 <code>dispatcher</code>传递数据给<code>store</code></li>
</ul>
<p>针对上面提到的 Flux 这些概念，需要写一个简单的类库来实现衔接这些功能，市面上有很多种实现，这里讨论 Facebook 官方的一个实现 <code>Dispatcher.js</code><br><strong>单向数据流</strong><br>先来了解一下 Flux 的核心“单向数据流“怎么运作的：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Action -&gt; Dispatcher -&gt; Store -&gt; View</div></pre></td></tr></table></figure>
<p>更多时候 View 会通过用户交互触发 Action，所以一个简单完整的数据流类似这样：<br><img src="http://omqyp2bk2.bkt.clouddn.com/1478598153291.png" alt="Alt text"></p>
<p>整个流程如下：</p>
<ul>
<li>首先要有 action，通过定义一些<code>action creator</code> 方法根据需要创建 Action 提供给 dispatcher</li>
<li>View 层通过用户交互（比如 onClick）会触发 Action</li>
<li>Dispatcher 会分发触发的 Action 给所有注册的 Store 的回调函数</li>
<li>Store 回调函数根据接收的 Action 更新自身数据之后会触发一个 <code>change</code>事件通知 <code>View</code> 数据更改了</li>
<li>View 会监听这个<code>change</code> 事件，拿到对应的新数据并调用 <code>setState</code> 更新组件 UI</li>
</ul>
<blockquote>
<p>所有的状态都由 <code>Store</code>来维护，通过<code>Action</code>传递数据，构成了如上所述的单向数据流循环，所以应用中的各部分分工就相当明确，高度解耦了。</p>
</blockquote>
<p>这种单向数据流使得整个系统都是透明可预测的。<br><strong>Dispatcher</strong></p>
<blockquote>
<p>一个应用只需要一个<code>dispatcher</code>作为分发中心，管理所有数据流向，分发动作给<code>Store</code>，没有太多其他的逻辑（一些 <code>action creator</code>方法也可以放到这里）。</p>
</blockquote>
<p>Dispatcher 分发动作给 Store 注册的回调函数，这和一般的订阅/发布模式不同的地方在于：</p>
<ul>
<li>回调函数不是订阅到某一个特定的事件/频道，每个动作会分发给所有注册的回调函数</li>
<li>回调函数可以指定在其他回调之后调用</li>
</ul>
<p>基于 Flux 的架构思路，<code>Dispatcher.js</code>提供的 API 很简单：</p>
<ul>
<li><strong>register(function callback): string </strong>注册回调函数，返回一个<code>token</code>供在<code>waitFor()</code>使用</li>
<li><strong>unregister(string id): void </strong>通过 token 移除回调</li>
<li><strong>waitFor(array ids): void </strong>在指定的回调函数执行之后才执行当前回调。这个方法<code>只能在分发动作的回调函数中使用</code></li>
<li><strong>dispatch(object payload): void </strong>分发动作 <code>payload</code>给所有注册回调</li>
<li><strong>isDispatching(): boolean </strong>返回 Dispatcher 当前是否处在分发的状态</li>
</ul>
<p>dispatcher 只是一个粘合剂，剩余的 Store、View、Action 就需要按具体需求去实现了。<br>接下来结合<code>flux-todomvc</code> 这个简单的例子，提取其中的关键部分，看一下实际应用中如何衔接 Flux 整个流程，希望能对 Flux 各个部分有更直观深入的理解。<br><strong>Action</strong></p>
<p>首先要创建动作，通过定义一些<code>action creator</code>方法来创建，这些方法用来暴露给外部调用，通过<code>dispatch</code>分发对应的动作，所以<code>action creator</code> 也称作<code>dispatcher helper methods</code>辅助 dipatcher 分发。 参见 <strong>actions/TodoActions.js</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> AppDispatcher = <span class="built_in">require</span>(<span class="string">'../dispatcher/AppDispatcher'</span>);</div><div class="line"><span class="keyword">var</span> TodoConstants = <span class="built_in">require</span>(<span class="string">'../constants/TodoConstants'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> TodoActions = &#123;</div><div class="line">  <span class="attr">create</span>: <span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">    AppDispatcher.dispatch(&#123;</div><div class="line">      <span class="attr">actionType</span>: TodoConstants.TODO_CREATE,</div><div class="line">      <span class="attr">text</span>: text</div><div class="line">    &#125;);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">updateText</span>: <span class="function"><span class="keyword">function</span>(<span class="params">id, text</span>) </span>&#123;</div><div class="line">    AppDispatcher.dispatch(&#123;</div><div class="line">      <span class="attr">actionType</span>: TodoConstants.TODO_UPDATE_TEXT,</div><div class="line">      <span class="attr">id</span>: id,</div><div class="line">      <span class="attr">text</span>: text</div><div class="line">    &#125;);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="comment">// 不带 payload 数据的动作</span></div><div class="line">  toggleCompleteAll: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    AppDispatcher.dispatch(&#123;</div><div class="line">      <span class="attr">actionType</span>: TodoConstants.TODO_TOGGLE_COMPLETE_ALL</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>AppDispatcher</code>直接继承自 <code>Dispatcher.js</code>，在这个简单的例子中没有提供什么额外的功能。<code>TodoConstants</code> 定义了动作的类型名称常量。<br>类似 <code>create</code>、<code>updateText</code> 就是 <strong>action creator</strong>，这两个动作会通过 View 上的用户交互触发（比如输入框）。 除了用户交互会创建动作，服务端接口调用也可以用来创建动作，比如通过<code>Ajax</code>请求的一些初始数据也可以创建动作提供给 dispatcher，再分发给 store 使用这些初始数据。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">action creators are nothing more than a call into the dispatcher.</div></pre></td></tr></table></figure>
<p>可以看到所谓<strong>动作就是用来封装传递数据的，动作只是一个简单的对象</strong>，包含两部分：<code>payload（数据）</code>和 <code>type（类型）</code>，type 是一个字符串常量，用来标识动作。</p>
<p><strong>Store</strong><br>Stores 包含<code>应用的状态和逻辑</code>，不同的 Store 管理应用中不同部分的状态。如 <code>stores/TodoStore.js</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> AppDispatcher = <span class="built_in">require</span>(<span class="string">'../dispatcher/AppDispatcher'</span>);</div><div class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter;</div><div class="line"><span class="keyword">var</span> TodoConstants = <span class="built_in">require</span>(<span class="string">'../constants/TodoConstants'</span>);</div><div class="line"><span class="keyword">var</span> assign = <span class="built_in">require</span>(<span class="string">'object-assign'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> CHANGE_EVENT = <span class="string">'change'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> _todos = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 先定义一些数据处理方法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> id = (+<span class="keyword">new</span> <span class="built_in">Date</span>() + <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">999999</span>)).toString(<span class="number">36</span>);</div><div class="line">  _todos[id] = &#123;</div><div class="line">    <span class="attr">id</span>: id,</div><div class="line">    <span class="attr">complete</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">text</span>: text</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">id, updates</span>) </span>&#123;</div><div class="line">  _todos[id] = assign(&#123;&#125;, _todos[id], updates);</div><div class="line">&#125;</div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> TodoStore = assign(&#123;&#125;, EventEmitter.prototype, &#123;</div><div class="line">  <span class="comment">// Getter 方法暴露给外部获取 Store 数据</span></div><div class="line">  getAll: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> _todos;</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 触发 change 事件</span></div><div class="line">  emitChange: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.emit(CHANGE_EVENT);</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 提供给外部 View 绑定 change 事件</span></div><div class="line">  addChangeListener: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.on(CHANGE_EVENT, callback);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 注册到 dispatcher，通过动作类型过滤处理当前 Store 关心的动作</span></div><div class="line">AppDispatcher.register(<span class="function"><span class="keyword">function</span>(<span class="params">action</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> text;</div><div class="line"></div><div class="line">  <span class="keyword">switch</span>(action.actionType) &#123;</div><div class="line">    <span class="keyword">case</span> TodoConstants.TODO_CREATE:</div><div class="line">      text = action.text.trim();</div><div class="line">      <span class="keyword">if</span> (text !== <span class="string">''</span>) &#123;</div><div class="line">        create(text);</div><div class="line">      &#125;</div><div class="line">      TodoStore.emitChange();</div><div class="line">      <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> TodoConstants.TODO_UPDATE_TEXT:</div><div class="line">      text = action.text.trim();</div><div class="line">      <span class="keyword">if</span> (text !== <span class="string">''</span>) &#123;</div><div class="line">        update(action.id, &#123;<span class="attr">text</span>: text&#125;);</div><div class="line">      &#125;</div><div class="line">      TodoStore.emitChange();</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在 <code>Store</code>注册给 <code>dispatcher</code> 的回调函数中会接受到分发的 <code>action</code>，因为每个 action 都会分发给所有注册的回调，所以回调函数里面要判断这个 action 的 type 并调用相关的内部方法处理更新 action 带过来的数据（payload），再通知 view 数据变更。<br>Store 里面不会暴露直接操作数据的方法给外部，暴露给外部调用的方法都是 <strong>Getter 方法</strong>，没有 <strong>Setter 方法</strong>，唯一更新数据的手段就是通过在 dispatcher 注册的回调函数。</p>
<p><strong>View</strong></p>
<blockquote>
<p>View 就是<code>React 组件</code>，<strong>从 Store 获取状态（数据），绑定 change 事件处理</strong>。如 <code>components/TodoApp.react.js</code></p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</div><div class="line"><span class="keyword">var</span> TodoStore = <span class="built_in">require</span>(<span class="string">'../stores/TodoStore'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTodoState</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">allTodos</span>: TodoStore.getAll(),</div><div class="line">    <span class="attr">areAllComplete</span>: TodoStore.areAllComplete()</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> TodoApp = React.createClass(&#123;</div><div class="line"></div><div class="line">  <span class="attr">getInitialState</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> getTodoState();</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">componentDidMount</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    TodoStore.addChangeListener(<span class="keyword">this</span>._onChange);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">componentWillUnmount</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    TodoStore.removeChangeListener(<span class="keyword">this</span>._onChange);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>/*...*/<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">_onChange</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.setState(getTodoState());</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>一个 View 可能关联多个 Store 来管理不同部分的状态</strong>，得益于 React 更新 View 如此简单（<code>setState</code>），复杂的逻辑都被 Store 隔离了。</p>
<h4 id="1-5-2-Redux"><a href="#1-5-2-Redux" class="headerlink" title="1.5.2 Redux"></a>1.5.2 Redux</h4><p><code>Dan Abramov</code> 在 <code>React Europe 2015</code>上作了一场令人印象深刻的演示<code>Hot Reloading with Time Travel</code>，之后 Redux 迅速成为最受人关注的 Flux 实现之一。+</p>
<blockquote>
<p>Redux 把自己标榜为一个<strong>“可预测的状态容器”</strong>，其实也是 <strong>Flux 里面“单向数据流”的思想</strong>，只是它充分利用<code>函数式</code>的特性，让整个实现更加优雅纯粹，使用起来也更简单。</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Redux(oldState) =&gt; newState</div></pre></td></tr></table></figure>
<p>Redux 是超越 Flux 的一次进化。</p>
<h5 id="1-5-2-1-进化-Flux"><a href="#1-5-2-1-进化-Flux" class="headerlink" title="1.5.2.1 进化 Flux"></a>1.5.2.1 进化 Flux</h5><p>首先是<code>action creators</code>，Flux 是直接在 action 里面调用 dispatch：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">  AppDispatcher.dispatch(&#123;</div><div class="line">    <span class="attr">type</span>: ActionTypes.ADD_TODO,</div><div class="line">    <span class="attr">text</span>: text</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Redux 把它简化成了这样：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">type</span>: ActionTypes.ADD_TODO,</div><div class="line">    <span class="attr">text</span>: text</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这一步把 dispatcher 和 action 解藕了，很快我们就能看到它带来的好处。<br>接下来是 Store，这是 Flux 里面的 Store：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> _todos = [];</div><div class="line"><span class="keyword">const</span> TodoStore = <span class="built_in">Object</span>.assign(<span class="keyword">new</span> EventEmitter(), &#123;</div><div class="line">  getTodos() &#123;</div><div class="line">    <span class="keyword">return</span> _todos;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">AppDispatcher.register(<span class="function"><span class="keyword">function</span> (<span class="params">action</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">  <span class="keyword">case</span> ActionTypes.ADD_TODO:</div><div class="line">    _todos = _todos.concat([action.text]);</div><div class="line">    TodoStore.emitChange();</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> TodoStore;</div></pre></td></tr></table></figure>
<p>Redux 把它简化成了这样：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> initialState = &#123; <span class="attr">todos</span>: [] &#125;;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">TodoStore</span>(<span class="params">state = initialState, action</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">  <span class="keyword">case</span> ActionTypes.ADD_TODO:</div><div class="line">    <span class="keyword">return</span> &#123; <span class="attr">todos</span>: state.todos.concat([action.text]) &#125;;</div><div class="line">  <span class="keyword">default</span>:</div><div class="line">    <span class="keyword">return</span> state;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样把 dispatch 从 Store 里面剥离了，Store 变成了一个 <strong>pure function</strong>：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(state, action) =&gt; state</div></pre></td></tr></table></figure>
<p><strong>什么是 pure function</strong><br>如果一个函数没有任何副作用（<code>side-effects</code>)，不会影响任何外部状态，对于任何一个相同的输入（参数），无论何时调用这个函数总是返回同样的结果，这个函数就是一个 <strong>pure function</strong>。所谓 side-effects 就是会改变外部状态的因素 ，比如 Ajax 请求就有 side-effects，因为它带来了不确定性。</p>
<p>所以现在 Store 不再拥有状态，而只是<strong>管理状态</strong>，所以首先要明确一个概念，<strong>Store 和 State 是有区别的，Store 并不是一个简单的数据结构，State 才是，Store 会包含一些方法来管理 State，比如获取／修改 State。</strong><br>基于这样的 Store，可以做很多扩展，这也是 Redux 强大之处。</p>
<h5 id="1-5-2-2-Redux-的基础概念"><a href="#1-5-2-2-Redux-的基础概念" class="headerlink" title="1.5.2.2 Redux 的基础概念"></a>1.5.2.2 Redux 的基础概念</h5><p><strong>三个基本原则</strong></p>
<ul>
<li>整个应用只有唯一一个可信数据源，也就是<strong>只有一个 Store</strong></li>
<li>State 只能通过触发<code>Action</code> 来更改</li>
<li>State 的更改必须写成<code>纯函数</code>，也就是<strong>每次更改总是返回一个新的 State</strong>，在 Redux 里这种函数称为<code>Reducer</code></li>
</ul>
<p><strong>Actions</strong><br>Action 很简单，就是一个单纯的包含<code>{ type, payload }</code>的对象，type 是一个常量用来标示动作类型，payload 是这个动作携带的数据。Action 需要通过<code>store.dispatch()</code>方法来发送。<br>比如一个最简单的 action：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">type</span>: <span class="string">'ADD_TODO'</span>,</div><div class="line">  <span class="attr">text</span>: <span class="string">'Build my first Redux app'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>一般来说，会使用函数（Action Creators）来生成 action，这样会有更大的灵活性，Action Creators 是一个 <strong>pure function</strong>，它最后会返回一个 action 对象：</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">'ADD_TODO'</span>,</div><div class="line">    text</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以现在要触发一个动作只要调用<code>dispatch: dispatch(addTodo(text))</code><br><strong>Reducers</strong></p>
<blockquote>
<p>Reducer 用来处理 Action 触发的对状态树的更改。</p>
</blockquote>
<p>所以一个 reducer 函数会接受 <code>oldState</code> 和 <code>action</code>两个参数，返回一个新的 state：<code>(oldState, action) =&gt; newState</code>。一个简单的 reducer 可能类似这样：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> initialState = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="string">'a'</span>,</div><div class="line">  <span class="attr">b</span>: <span class="string">'b'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">someApp</span>(<span class="params">state = initialState, action</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'CHANGE_A'</span>:</div><div class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">a</span>: <span class="string">'Modified a'</span> &#125;;</div><div class="line">    <span class="keyword">case</span> <span class="string">'CHANGE_B'</span>:</div><div class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">b</span>: action.payload &#125;;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      <span class="keyword">return</span> state</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>值得注意的有两点：</p>
<ul>
<li>我们用到了<code>object spread</code>语法 确保不会更改到<code>oldState</code> 而是返回一个 <code>newState</code></li>
<li>对于不需要处理的 action，直接返回<code>oldState</code></li>
</ul>
<p>Reducer 也是 <code>pure function</code>，这点非常重要，所以绝对不要在 reducer 里面做一些引入 side-effects 的事情，比如：</p>
<ul>
<li>直接修改 state 参数对象</li>
<li>请求 API</li>
<li>调用不纯的函数，比如 <code>Data.now() Math.random()</code></li>
</ul>
<p>因为 Redux 里面只有一个 Store，对应一个 State 状态，所以整个 State 对象就是由一个 reducer 函数管理，但是如果所有的状态更改逻辑都放在这一个 reducer 里面，显然会变得越来越巨大，越来越难以维护。得益于纯函数的实现，我们只需要稍微变通一下，让状态树上的每个字段都有一个 reducer 函数来管理就可以拆分成很小的 reducer 了：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">someApp</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">a</span>: reducerA(state.a, action),</div><div class="line">    <span class="attr">b</span>: reducerB(state.b, action)</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于 reducerA 和 reducerB 来说，他们依然是形如：<code>(oldState, action) =&gt; newState</code>的函数，只是这时候的 state 不是整个状态树，而是树上的特定字段，每个 reducer 只需要判断 action，管理自己关心的状态字段数据就好了。<br>Redux 提供了一个<code>工具函数 combineReducers</code>来简化这种 reducer 合并：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> someApp = combineReducers(&#123;</div><div class="line">  <span class="attr">a</span>: reducerA,</div><div class="line">  <span class="attr">b</span>: reducerB</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如果 reducer 函数名字和字段名字相同，利用 ES6 的 <code>Destructuring</code>可以进一步简化成：<code>combineReducers({ a, b })</code></p>
<blockquote>
<p>象<code>someApp</code>这种管理整个 State 的 reducer，可以称为 <strong>root reducer</strong>。</p>
</blockquote>
<p><strong>Store</strong></p>
<blockquote>
<p>现在有了 Action 和 Reducer，<strong>Store 的作用就是连接这两者</strong>，Store 的作用有这么几个：</p>
</blockquote>
<ul>
<li>Hold 住整个应用的 State 状态树</li>
<li>提供一个 <code>getState()</code>方法获取 State</li>
<li>提供一个 <code>dispatch()</code>方法发送 action 更改 State</li>
<li>提供一个<code>subscribe()</code>方法注册回调函数监听 State 的更改</li>
</ul>
<p>创建一个 Store 很容易，将<code>root reducer 函数</code>传递给<code>createStore</code>方法即可：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"><span class="keyword">import</span> someApp <span class="keyword">from</span> <span class="string">'./reducers'</span>;</div><div class="line"><span class="keyword">let</span> store = createStore(someApp);</div><div class="line"></div><div class="line"><span class="comment">// 你也可以额外指定一个初始 State（initialState），这对于服务端渲染很有用</span></div><div class="line"><span class="comment">// let store = createStore(someApp, window.STATE_FROM_SERVER);</span></div></pre></td></tr></table></figure>
<p>现在我们就拿到了 <code>store.dispatch</code>，可以用来分发 action 了：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> unsubscribe = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(store.getState()));</div><div class="line"></div><div class="line"><span class="comment">// Dispatch</span></div><div class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'CHANGE_A'</span> &#125;);</div><div class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'CHANGE_B'</span>, <span class="attr">payload</span>: <span class="string">'Modified b'</span> &#125;);</div><div class="line"></div><div class="line"><span class="comment">// Stop listening to state updates</span></div><div class="line">unsubscribe();</div></pre></td></tr></table></figure>
<p><strong>Data Flow</strong><br>以上提到的<code>store.dispatch(action) -&gt; reducer(state, action) -&gt; store.getState()</code>其实就构成了一个<strong>“单向数据流”</strong>，我们再来总结一下。<br>1、调用 <code>store.dispatch(action)</code><br>Action 是一个包含<code>{ type, payload }</code>的对象，它描述了“发生了什么”，比如：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="attr">type</span>: <span class="string">'LIKE_ARTICLE'</span>, <span class="attr">articleID</span>: <span class="number">42</span> &#125;</div><div class="line">&#123; <span class="attr">type</span>: <span class="string">'FETCH_USER_SUCCESS'</span>, <span class="attr">response</span>: &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">'Mary'</span> &#125; &#125;</div><div class="line">&#123; <span class="attr">type</span>: <span class="string">'ADD_TODO'</span>, <span class="attr">text</span>: <span class="string">'Read the Redux docs.'</span> &#125;</div></pre></td></tr></table></figure>
<p>可以在任何地方调用<code>store.dispatch(action)</code>，比如<strong>组件内部</strong>，<strong>Ajax 回调函数里面</strong>等等。<br>2、<strong>Action </strong>会触发给 <strong>Store</strong> 指定的 <strong>root reducer</strong></p>
<blockquote>
<p><strong>root reducer </strong>会返回一个完整的状态树，State 对象上的各个字段值可以由各自的 reducer 函数处理并返回新的值。</p>
</blockquote>
<ul>
<li>reducer 函数接受<code>(state, action)</code>两个参数</li>
<li>reducer 函数判断 <code>action.type</code>然后处理对应的 <code>action.payload</code>数据来更新并返回一个新的 state</li>
</ul>
<p>3、<strong>Store</strong> 会保存 <strong>root reducer </strong>返回的状态树<br>新的 State 会替代旧的 State，然后所有 <code>store.subscribe(listener)</code>注册的回调函数会被调用，在回调函数里面可以通过 <code>store.getState()</code>拿到新的 State。</p>
<h5 id="1-5-2-4-Redux进阶"><a href="#1-5-2-4-Redux进阶" class="headerlink" title="1.5.2.4 [Redux进阶]"></a>1.5.2.4 [Redux进阶]</h5><h3 id="1-6-表单"><a href="#1-6-表单" class="headerlink" title="1.6 表单"></a>1.6 表单</h3><p>表单不同于其他 HTML 元素，因为它要响应用户的交互，显示不同的状态，所以在 React 里面会有点特殊。<br><strong>状态属性</strong><br>表单元素有这么几种属于状态的属性：</p>
<ul>
<li><strong>value</strong>，对应<code>&lt;input&gt;</code>和 <code>&lt;textarea&gt;</code>所有</li>
<li><strong>checked</strong>，对应类型为<code>checkbox</code>和<code>radio</code>的 <code>&lt;input&gt;</code> 所有</li>
<li><strong>selected</strong>，对应<code>&lt;option&gt;</code> 所有</li>
</ul>
<blockquote>
<p>在 HTML 中<code>&lt;textarea&gt;</code>的值可以由子节点（文本）赋值，但是在 React 中，要用<code>value</code> 来设置。<br>表单元素包含以上任意一种状态属性都支持 <code>onChange</code> 事件监听状态值的更改。</p>
</blockquote>
<p>针对这些状态属性不同的处理策略，表单元素在 React 里面有两种表现形式。<br><strong>受控组件</strong><br>对于设置了上面提到的对应“状态属性“值的表单元素就是<strong>受控表单组件</strong>，比如：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"hello"</span>/&gt;</span>;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个受控的表单组件，它所有状态属性更改涉及 UI 的变更都由 React 来控制（状态属性绑定 UI）。比如上面代码里的<code>&lt;input&gt;</code>输入框，用户输入内容，用户输入的内容不会显示（输入框总是显示状态属性 value 的值 hello），这有点颠覆我们的认知了，所以说这是受控组件，不是原来默认的表单元素了。</p>
<p>如果你希望输入的内容反馈到输入框，就要用 <code>onChange</code>事件改变状态属性 value 的值：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;<span class="attr">value</span>: <span class="string">'hello'</span>&#125;;</div><div class="line">&#125;,</div><div class="line"><span class="attr">handleChange</span>: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: event.target.value&#125;);</div><div class="line">&#125;,</div><div class="line"><span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> value = <span class="keyword">this</span>.state.value;</div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span> /&gt;</span>;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用这种模式非常容易实现类似对用户输入的验证，或者对用户交互做额外的处理，比如截断最多输入140个字符：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">handleChange: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: event.target.value.substr(<span class="number">0</span>, <span class="number">140</span>)&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>非受控组件</strong></p>
<blockquote>
<p>和受控组件相对，如果表单元素<strong>没有设置自己的“状态属性”</strong>，或者<strong>属性值设置为 null</strong>，这时候就是非受控组件。</p>
</blockquote>
<p>它的表现就符合普通的表单元素，正常响应用户的操作。<br>同样，也可以绑定<code>onChange</code>事件处理交互。</p>
<blockquote>
<p>如果想要给“状态属性”设置默认值，就要用 React 提供的特殊属性 <code>defaultValue</code>，对于 <code>checked</code>会有 <code>defaultChecked</code>，<code>&lt;option&gt;</code> 也是使用 <code>defaultValue</code>。</p>
</blockquote>
<p><strong>为什么要有受控组件？</strong><br>引入受控组件不是说它有什么好处，而是因为 React 的 UI 渲染机制，对于表单元素不得不引入这一特殊的处理方式。<br>在浏览器 DOM 里面是有区分 <code>attribute</code> 和 <code>property</code> 的。</p>
<blockquote>
<p><strong>attribute</strong> 是在 HTML 里指定的属性，而每个 HTML 元素在 JS 对应是一个 DOM 节点对象，这个对象拥有的属性就是 property（可以在 console 里展开一个 DOM 节点对象看一下，HTML attributes 只是对应其中的一部分属性），attribute 对应的 property 会从 attribute 拿到初始值，有些会有相同的名称，但是有些名称会不一样，比如 attribute class 对应的 property 就是<code>className</code>。（详细解释：<code>.prop</code>，<code>.prop() vs .attr()</code>）</p>
</blockquote>
<p>回到 React 里的<code>&lt;input&gt;</code> 输入框，当用户输入内容的时候，输入框的 <code>value property</code> 会改变，但是 <code>value attribute</code> 依然会是 HTML 上指定的值（attribute 要用 <code>setAttribute</code>去更改）。<br>React 组件必须呈现这个组件的状态视图，这个视图 HTML 是由<code>render</code>生成，所以对于</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"hello"</span>/&gt;</span>;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在任意时刻，这个视图总是返回一个显示<code>hello</code>的输入框。<br><strong><code>&lt;select&gt;</code></strong><br>在 HTML 中<code>&lt;select&gt;</code> 标签指定选中项都是通过对应<code>&lt;option&gt;</code> 的 <code>selected</code>属性来做的，但是在 React 修改成统一使用<code>value</code>。<br>所以没有一个 <strong>selected 的状态属性</strong>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">value</span>=<span class="string">"B"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"A"</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"B"</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"C"</span>&gt;</span>Cranberry<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure>
<p>可以通过传递一个数组指定多个选中项：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">multiple</span>=<span class="string">&#123;true&#125;</span> <span class="attr">value</span>=<span class="string">&#123;[</span>'<span class="attr">B</span>', '<span class="attr">C</span>']&#125;&gt;</span></div></pre></td></tr></table></figure>
<h3 id="1-10-服务端渲染"><a href="#1-10-服务端渲染" class="headerlink" title="1.10 服务端渲染"></a>1.10 服务端渲染</h3><blockquote>
<p>React 提供了两个方法<code>renderToString</code> 和 <code>renderToStaticMarkup</code>用来将组件（Virtual DOM）输出成 HTML 字符串，这是 React 服务器端渲染的基础，它移除了服务器端对于浏览器环境的依赖，所以让服务器端渲染变成了一件有吸引力的事情。</p>
</blockquote>
<p>服务器端渲染除了要解决对浏览器环境的依赖，还要解决两个问题：</p>
<ul>
<li>前后端可以共享代码</li>
<li>前后端路由可以统一处理</li>
</ul>
<p>React 生态提供了很多选择方案，这里我们选用 <code>Redux</code>和 <code>react-router</code>来做说明。<br><strong>Redux</strong><br>Redux 提供了一套类似 Flux 的单向数据流，整个应用只维护一个 Store，以及面向函数式的特性让它对服务器端渲染支持很友好。</p>
<p>关于 <strong>Store</strong>：</p>
<ul>
<li>整个应用只有一个唯一的 Store</li>
<li>Store 对应的状态树（State），由调用一个<code>- reducer</code> 函数（<code>root reducer</code>）生成</li>
<li>状态树上的每个字段都可以进一步由不同的 reducer 函数生成</li>
<li>Store 包含了几个方法比如<code>dispatch</code>, <code>getState</code> 来处理数据流</li>
<li>Store 的状态树只能由<code>dispatch(action)</code>来触发更改</li>
</ul>
<p><strong>Redux 的数据流</strong>：</p>
<ul>
<li>action 是一个包含 <code>{ type, payload }</code>的对象</li>
<li>reducer 函数通过 <code>store.dispatch(action)</code>触发</li>
<li>reducer 函数接受<code>(state, action)</code>两个参数，返回一个新的 state</li>
<li>reducer 函数判断<code>action.type</code>然后处理对应的<code>action.payload</code>数据来更新状态树</li>
</ul>
<blockquote>
<p>所以对于整个应用来说，一个 Store 就对应一个 UI 快照，<strong>服务器端渲染</strong>就简化成了在服务器端初始化 Store，将 Store 传入应用的根组件，针对根组件调用 <code>renderToString</code>就将整个应用输出成包含了初始化数据的 HTML。</p>
</blockquote>
<p><strong>react-router</strong></p>
<blockquote>
<p>react-router 通过一种<strong>声明式</strong>的方式匹配不同路由决定在页面上展示不同的组件，并且通过 <code>props</code>将路由信息传递给组件使用，所以只要路由变更，props 就会变化，触发组件<code>re-render</code>。</p>
</blockquote>
<p>假设有一个很简单的应用，只有两个页面，一个列表页<code>/list</code>和一个详情页 <code>/item/:id</code>，点击列表上的条目进入详情页。<br>可以这样定义路由，<code>./routes.js</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123; Route &#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</div><div class="line"><span class="keyword">import</span> &#123; List, Item &#125; <span class="keyword">from</span> <span class="string">'./components'</span>;</div><div class="line"></div><div class="line"><span class="comment">// 无状态（stateless）组件，一个简单的容器，react-router 会根据 route</span></div><div class="line"><span class="comment">// 规则匹配到的组件作为 `props.children` 传入</span></div><div class="line"><span class="keyword">const</span> Container = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">  );</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// route 规则：</span></div><div class="line"><span class="comment">// - `/list` 显示 `List` 组件</span></div><div class="line"><span class="comment">// - `/item/:id` 显示 `Item` 组件</span></div><div class="line"><span class="keyword">const</span> routes = (</div><div class="line">  &lt;Route path="/" component=&#123;Container&#125; &gt;</div><div class="line">    &lt;Route path="list" component=&#123;List&#125; /&gt;</div><div class="line">    &lt;Route path="item/:id" component=&#123;Item&#125; /&gt;</div><div class="line">  &lt;/Route&gt;</div><div class="line">);</div><div class="line"></div><div class="line">export default routes;</div></pre></td></tr></table></figure>
<p>从这里开始，我们通过这个非常简单的应用来解释实现服务器端渲染前后端涉及的一些细节问题。<br><strong>Reducer</strong><br>Store 是由 reducer 产生的，所以 reducer 实际上反映了 Store 的状态树结构<br><code>./reducers/index.js</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> listReducer <span class="keyword">from</span> <span class="string">'./list'</span>;</div><div class="line"><span class="keyword">import</span> itemReducer <span class="keyword">from</span> <span class="string">'./item'</span>;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">rootReducer</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">list</span>: listReducer(state.list, action),</div><div class="line">    <span class="attr">item</span>: itemReducer(state.item, action)</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>rootReducer</code> 的 <code>state</code> 参数就是整个 Store 的状态树，状态树下的每个字段对应也可以有自己的 reducer，所以这里引入了<code>listReducer</code> 和 <code>itemReducer</code>，可以看到这两个 reducer 的 state 参数就只是整个状态树上对应的 list 和 item 字段。<br>具体到<code>./reducers/list.js</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> initialState = [];</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">listReducer</span>(<span class="params">state = initialState, action</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span>(action.type) &#123;</div><div class="line">  <span class="keyword">case</span> <span class="string">'FETCH_LIST_SUCCESS'</span>: <span class="keyword">return</span> [...action.payload];</div><div class="line">  <span class="keyword">default</span>: <span class="keyword">return</span> state;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>list 就是一个包含 items 的简单数组，可能类似这种结构：<code>[{ id: 0, name: &#39;first item&#39;}, {id: 1, name: &#39;second item&#39;}]</code>，从 <code>&#39;FETCH_LIST_SUCCESS&#39;</code> 的 <code>action.payload</code> 获得。<br>然后是<code>./reducers/item.js</code>，处理获取到的 item 数据</p>
<p><strong>Action</strong><br>对应的应该要有两个 action 来获取 list 和 item，触发 reducer 更改 Store，这里我们定义 <code>fetchList</code> 和<code>fetchItem</code> 两个 action。x<br><code>./actions/index.js</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> fetch <span class="keyword">from</span> <span class="string">'isomorphic-fetch'</span>;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> fetch(<span class="string">'/api/list'</span>)</div><div class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</div><div class="line">      .then(<span class="function"><span class="params">json</span> =&gt;</span> dispatch(&#123; <span class="attr">type</span>: <span class="string">'FETCH_LIST_SUCCESS'</span>, <span class="attr">payload</span>: json &#125;));</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchItem</span>(<span class="params">id</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (!id) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</div><div class="line">    <span class="keyword">return</span> fetch(<span class="string">`/api/item/<span class="subst">$&#123;id&#125;</span>`</span>)</div><div class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</div><div class="line">      .then(<span class="function"><span class="params">json</span> =&gt;</span> dispatch(&#123; <span class="attr">type</span>: <span class="string">'FETCH_ITEM_SUCCESS'</span>, <span class="attr">payload</span>: json &#125;));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>isomorphic-fetch</code> 是一个前后端通用的<strong> Ajax 实现</strong>，前后端要共享代码这点很重要。<br>另外因为涉及到异步请求，这里的 action 用到了 thunk，也就是函数，redux 通过<code>thunk-middleware</code> 来处理这类 action，把函数当作普通的 action dispatch 就好了，比如 <code>dispatch(fetchList())</code><br><strong>Store</strong><br>我们用一个独立的 <code>./store.js</code>，配置（比如 Apply Middleware）生成 Store</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">'./reducers'</span>;</div><div class="line"></div><div class="line"><span class="comment">// Apply middleware here</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">configureStore</span>(<span class="params">initialState</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> store = createStore(rootReducer, initialState);</div><div class="line">  <span class="keyword">return</span> store;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>react-redux</strong><br>接下来就是实现<code>&lt;List&gt;</code>，<code>&lt;Item&gt;</code> 组件，然后把 Redux 和 React 组件关联起来，具体细节参见<code>react-redux</code><br><code>./app.js</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"><span class="keyword">import</span> &#123; Router &#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</div><div class="line"><span class="keyword">import</span> createBrowserHistory <span class="keyword">from</span> <span class="string">'history/lib/createBrowserHistory'</span>;</div><div class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</div><div class="line"><span class="keyword">import</span> routes <span class="keyword">from</span> <span class="string">'./routes'</span>;</div><div class="line"><span class="keyword">import</span> configureStore <span class="keyword">from</span> <span class="string">'./store'</span>;</div><div class="line"></div><div class="line"><span class="comment">// `__INITIAL_STATE__` 来自服务器端渲染，下一部分细说</span></div><div class="line"><span class="keyword">const</span> initialState = <span class="built_in">window</span>.__INITIAL_STATE__;</div><div class="line"><span class="keyword">const</span> store = configureStore(initialState);</div><div class="line"><span class="keyword">const</span> Root = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">      <span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">Router</span> <span class="attr">history</span>=<span class="string">&#123;createBrowserHistory()&#125;</span>&gt;</span></div><div class="line">          &#123;routes&#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  );</div><div class="line">&#125;</div><div class="line"></div><div class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">Root</span> /&gt;</span>, document.getElementById('root'));</span></div></pre></td></tr></table></figure>
<p>至此，客户端部分结束。</p>
<p><strong>Server Rendering</strong><br>接下来的<strong>服务器端</strong>就比较简单了，获取数据可以调用 action，routes 在服务器端的处理参考 <code>react-router</code> <code>server rendering</code>，在服务器端用一个<code>match</code> 方法将拿到的 <code>request url</code>匹配到我们之前定义的 routes，解析成和客户端一致的 props 对象传递给组件。<br><code>./server.js</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">'express'</span>;</div><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123; renderToString &#125; <span class="keyword">from</span> <span class="string">'react-dom/server'</span>;</div><div class="line"><span class="keyword">import</span> &#123; RoutingContext, match &#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</div><div class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</div><div class="line"><span class="keyword">import</span> routes <span class="keyword">from</span> <span class="string">'./routes'</span>;</div><div class="line"><span class="keyword">import</span> configureStore <span class="keyword">from</span> <span class="string">'./store'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> app = express();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderFullPage</span>(<span class="params">html, initialState</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">`</span></div><div class="line">    &lt;!DOCTYPE html&gt;</div><div class="line">    &lt;html lang="en"&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">      &lt;meta charset="UTF-8"&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">      &lt;div id="root"&gt;</div><div class="line">        &lt;div&gt;</div><div class="line">          <span class="subst">$&#123;html&#125;</span></div><div class="line">        &lt;/div&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">      &lt;script&gt;</div><div class="line">        window.__INITIAL_STATE__ = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(initialState)&#125;</span>;</div><div class="line">      &lt;/script&gt;</div><div class="line">      &lt;script src="/static/bundle.js"&gt;&lt;/script&gt;</div><div class="line">    &lt;/body&gt;</div><div class="line">    &lt;/html&gt;</div><div class="line">  `;</div><div class="line">&#125;</div><div class="line"></div><div class="line">app.use(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</div><div class="line">  match(&#123; routes, <span class="attr">location</span>: req.url &#125;, (err, redirectLocation, renderProps) =&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (err) &#123;</div><div class="line">      res.status(<span class="number">500</span>).end(<span class="string">`Internal Server Error <span class="subst">$&#123;err&#125;</span>`</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (redirectLocation) &#123;</div><div class="line">      res.redirect(redirectLocation.pathname + redirectLocation.search);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (renderProps) &#123;</div><div class="line">      <span class="keyword">const</span> store = configureStore();</div><div class="line">      <span class="keyword">const</span> state = store.getState();</div><div class="line"></div><div class="line">      <span class="built_in">Promise</span>.all([</div><div class="line">        store.dispatch(fetchList()),</div><div class="line">        store.dispatch(fetchItem(renderProps.params.id))</div><div class="line">      ])</div><div class="line">      .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">const</span> html = renderToString(</div><div class="line">          <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></div><div class="line">            <span class="tag">&lt;<span class="name">RoutingContext</span> &#123;<span class="attr">...renderProps</span>&#125; /&gt;</span></div><div class="line">          <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></div><div class="line">        );</div><div class="line">        res.end(renderFullPage(html, store.getState()));</div><div class="line">      &#125;);</div><div class="line">    &#125; else &#123;</div><div class="line">      res.status(404).end('Not found');</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>服务器端渲染部分可以直接通过共用客户端 <code>store.dispatch(action)</code>来统一获取 Store 数据。另外注意<code>renderFullPage</code>生成的页面 HTML 在 React 组件 mount 的部分<code>(&lt;div id=&quot;root&quot;&gt;)</code>，前后端的 HTML 结构应该是一致的。然后要把 store 的状态树写入一个全局变量（<strong>INITIAL_STATE</strong>），这样客户端初始化 render 的时候能够校验服务器生成的 HTML 结构，并且同步到初始化状态，然后整个页面被客户端接管。<br>最后关于页面内链接跳转如何处理？</p>
<p>react-router 提供了一个<code>&lt;Link&gt;</code>组件用来替代 <code>&lt;a&gt;</code> 标签，它负责管理浏览器 history，从而不是每次点击链接都去请求服务器，然后可以通过绑定 <code>onClick</code> 事件来作其他处理。</p>
<p>比如在 /list 页面，对于每一个 item 都会用 <code>&lt;Link&gt;</code>绑定一个 <code>route url：/item/:id</code>，并且绑定 onClick 去触发 <code>dispatch(fetchItem(id))</code>获取数据，显示详情页内容。</p>
<p><strong>更多参考</strong></p>
<ul>
<li>Universal (Isomorphic)</li>
<li>isomorphic-redux-app</li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JS/" rel="tag"># JS</a>
          
            <a href="/tags/JS框架／库/" rel="tag"># JS框架／库</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/13/JS-正则表达式/" rel="next" title="正则表达式">
                <i class="fa fa-chevron-left"></i> 正则表达式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/14/JS-JS简介和基本概念/" rel="prev" title="JS简介及基本概念">
                JS简介及基本概念 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Emily" />
          <p class="site-author-name" itemprop="name">Emily</p>
           
              <p class="site-description motion-element" itemprop="description">我学习 WEB 前端开发以来的笔记</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#React-分享"><span class="nav-text">React 分享</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-React-入门教程"><span class="nav-text">1 React 入门教程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-React-概览"><span class="nav-text">1.1 React 概览</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-组件"><span class="nav-text">1.1.1 组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-JSX"><span class="nav-text">1.1.2 JSX</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-3-Virtual-DOM"><span class="nav-text">1.1.3 Virtual DOM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-4-Data-Flow"><span class="nav-text">1.1.4 Data Flow</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-开发环境配置"><span class="nav-text">1.2 开发环境配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-Webpack-配置-React-开发环境"><span class="nav-text">1.2.1 Webpack 配置 React 开发环境</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-JSX"><span class="nav-text">1.3 JSX</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-使用-JSX"><span class="nav-text">1.3.1 使用 JSX</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2-属性扩散"><span class="nav-text">1.3.2 属性扩散</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-3-JSX-与-HTML-的差异"><span class="nav-text">1.3.3 JSX 与 HTML 的差异</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-React-组件"><span class="nav-text">1.4 React 组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-1-组件生命周期"><span class="nav-text">1.4.1 组件生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-2-事件处理（还需要再看看）"><span class="nav-text">1.4.2 事件处理（还需要再看看）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-3-DOM-操作"><span class="nav-text">1.4.3 DOM 操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-4-组合组件"><span class="nav-text">1.4.4 组合组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-5-组件间通信"><span class="nav-text">1.4.5 组件间通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-6-Minxins（再看看）"><span class="nav-text">1.4.6 Minxins（再看看）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-Data-Flow"><span class="nav-text">1.5 Data Flow</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-1-Flux"><span class="nav-text">1.5.1 Flux</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-2-Redux"><span class="nav-text">1.5.2 Redux</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-2-1-进化-Flux"><span class="nav-text">1.5.2.1 进化 Flux</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-2-2-Redux-的基础概念"><span class="nav-text">1.5.2.2 Redux 的基础概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-2-4-Redux进阶"><span class="nav-text">1.5.2.4 [Redux进阶]</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-表单"><span class="nav-text">1.6 表单</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-10-服务端渲染"><span class="nav-text">1.10 服务端渲染</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Emily</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
